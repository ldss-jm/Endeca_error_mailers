#!/bin/sh

# This script monitors the TRLN log file defined below for new errors. It
# notifies the dev listserv when errors are found. In any case, it logs results
# of a check to the this_script_log file and also uses that file to store
# the last line checked.
#
# To create a new this_script_log file or repair it from abort state,
# just do echo " n." where n+1 is the first line you want checked; n=0 for
# check entire file.


# config paths and email addresses
#
trlnlogfile="/data/TRLN/logs/TRLN.0.0.log"
this_script_log="/data/TRLN/logs/TRLNlog_error_mailer.log"
this_script="/data/util/TRLNlog_error_mailer.sh"

# dev listserv email
listserv_email="searchtrlnmgrs@listserv.unc.edu"
# support contact
support_email="eres_cat@unc.edu"

timestamp=$(date "+%F %T")
# define error message when script fails
scriptfailmessage="There is a problem with: $this_script
  Until you are notified otherwise, please expect that:
      $trlnlogfile
  is not being checked for errors. Sorry.
  Mail generated: $timestamp"


# If this script's log file does not exist, abort. Otherwise, get last
# linenumber checked ($prevlastchecked) from it.
#
if ! [ -f "$this_script_log" ]; then
  # This script is newly broken. Notify listserv this time.
  echo -e "$scriptfailmessage" | mail -s "Endeca Error Report - checker broken" "$listserv_email"
  echo "$timestamp This log file did not exist when last run. Listserv notified. Until fixed, this script will just abort." >> "$this_script_log"
  exit 100
fi
prevlastchecked=$(tail -n 1 "$this_script_log" | sed 's/.* \([0-9]*\).$/\1/')


#
# If valid $prevlastchecked not found, abort.
# If script was previously in an abort state and has not been fixed, abort and
# then notify only $support_email
#
re='^[0-9]+$'
if ! [[ "$prevlastchecked" =~ $re ]]; then
  if [[ "$prevlastchecked" =~ abort.$ ]]; then
    # This script is already broken; notify only $support_email.
    echo -e "$scriptfailmessage" | mail -s "Endeca Error Report - checker broken" "$support_email"
    echo "$timestamp Problem with this log file still exists. Support staff notified. Until fixed, this script will just abort." >> "$this_script_log"
    exit 100
  else
    # This script is newly broken. Notify listserv this time.
    echo -e "$scriptfailmessage" | mail -s "Endeca Error Report - checker broken" "$listserv_email"
    echo "$timestamp Problem with this log file. Listserv notified. Until fixed, this script will just abort." >> "$this_script_log"
    exit 100
  fi
fi

trlnloglength=$(wc -l < "$trlnlogfile")
newloglines=$(tail -n +$((1 + $prevlastchecked)) "$trlnlogfile")
newloglength=$(echo "$newloglines" | wc -l)
newlastchecked=$(($newloglength + $prevlastchecked))


#
# Handle cases where no new log lines found.
#
if [ "$newloglines" == "" ]; then
  if [  "$trlnloglength" == "" ]; then
    # TRLN log not found or read. This script is newly broken. Notify listserv this time.
    echo "$timestamp TRLN log could not be found or read. Last line checked: $prevlastchecked." >> "$this_script_log"
    echo -e "$scriptfailmessage" | mail -s "Endeca Error Report - checker broken" "$listserv_email"
    exit 100
  elif [ $prevlastchecked -eq $trlnloglength ]; then
    # Looks like TRLN log simply has no new lines since this script last run
    echo "$timestamp No new log lines detected. Last line checked: $prevlastchecked." >> "$this_script_log"
    exit 0
  else
    # The TRLN log must be shorter than the stated last line checked.
    # If the TRLN log is <30k lines, assume it's a new TRLN log;
    # otherwise, abort.
    #   If the assumption were wrong, the effect would be to error check the
    #   entire existing TRLN log file and report every error as a new error.
    if [ $trlnloglength -lt 30000 ];then
      echo "$timestamp New log file found. Last line checked: 0." >> "$this_script_log"
      prevlastchecked=0
      newloglines=$(cat "$trlnlogfile")
      newloglength=$(echo "$newloglines" | wc -l)
      newlastchecked=$newloglength
    else
      # This script is newly broken. Notify listserv this time.
      echo -e "$scriptfailmessage" | mail -s "Endeca Error Report - checker broken" "$listserv_email"
      echo "$timestamp TRLN log is shorter than expected and doesn't look new. Listserv notified. Until fixed, this script will just abort." >> "$this_script_log"    
      exit 100
    fi
  fi
fi

errorcount=$(echo "$newloglines" | grep -c '^SEVERE\|^WARNING')

# define header included when errors are found
header="There were $errorcount new errors found in: $trlnlogfile
  This check ran at: $timestamp
  This email was generated by: $this_script
  Problems with this script? Notify $support_email
  \nErrors:"

if [ $errorcount -eq 0 ]; then
  # no errors found
  echo "$timestamp No errors found. Last line checked: $newlastchecked." >> "$this_script_log"
else
  # errors found
  #
  # process newloglines; add an extra newline to the end at this late stage which:
  #   -happens too late to adversely affect the last line checked count
  #   -allows sed to print the error line if the error line would otherwise be the last line of the file
  # find /^SEVERE/^WARNING/ matches, return preceding line and text-until-datestamp for each
  #   For preceding line, see:
  #   https://unix.stackexchange.com/questions/206886/print-previous-line-after-a-pattern-match-using-sed#206887
  # provide newlines and separators for those matches
  errors=$(
  echo -e "$newloglines\n" |
  sed -n '/^SEVERE\|^WARNING/,/^[a-zA-Z]\{3\} [0-9]\{1,2\}, 20[0-9]\{2\}/{x;p;d}; x' |
  sed 's/^\([a-zA-Z]\{3\} [0-9]\{1,2\}, 20[0-9]\{2\}\)/\n_________________________\n\1/'
  )
  # send mail
  echo -e "$header$errors" | mail -s "Endeca Error Report" "$listserv_email"
    if [ $? -eq 0 ]; then
      # send mail succeeded
      echo "$timestamp Found $errorcount errors. Sent mail. Last line checked: $newlastchecked." >> "$this_script_log"
    else
      # send mail failed
      echo "$timestamp Found $errorcount errors. Sending mail failed. Last line checked: $newlastchecked." >> "$this_script_log"
    fi
fi
exit 0
